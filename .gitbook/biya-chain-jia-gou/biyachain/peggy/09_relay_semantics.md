---
sidebar_position: 9
title: 中继语义
---

# 中继语义

本文档旨在帮助开发人员实现替代的 Peggy 中继者。与 Ethereum 交互的 Orchestrator 的两个主要组件。Peggy 桥接的设计是为了提高效率，而不是为了易于使用。这意味着这些外部二进制文件有许多隐式要求，本文档尽力使其明确。

Peggy `orchestrator` 结合了 Peggy 桥接中需要由外部二进制文件执行的三个不同角色。本文档重点介绍 `relayer` 的要求，这是 `orchestrator` 中包含的角色之一。

## 验证者集更新中继的语义

### 验证者集和签名的排序和顺序

在更新 Peggy 合约中的验证者集时，您必须提供旧验证者集的副本。这_必须_只能从 Ethereum 链上的最后一个 ValsetUpdated 事件中获取。

提供旧验证者集是存储优化的一部分，不是将整个验证者集存储在 Ethereum 存储中，而是由每个调用者提供并存储在更便宜的 Ethereum 事件队列中。Peggy 合约中不执行任何类型的排序，这意味着验证者列表及其新签名必须按照与上次调用完全相同的顺序提交。

为了正常操作的目的，此要求可以简化为"按降序权重排序验证者，在权重相等时按 Eth 地址字节排序"。由于 peggy 模块生成验证者集，它们应该始终按顺序出现。中继者无法更改此顺序，因为它是签名的一部分。但是 Peggy 模块端此排序方法的更改将停止 valset 更新并基本上解耦桥接，除非您的实现足够智能，可以查看最后提交的顺序而不是盲目遵循排序。

### 决定中继哪个验证者集

Biya Chain 简单地产生验证者集流，它不对它们如何中继做出任何判断。由中继者实现来确定如何优化此中继操作的 gas 成本。

例如，假设我们有验证者集 `A、B、C 和 D`，当存储中最后一个 Peggy 验证者集快照与当前活跃验证者集之间存在 5% 权重差异时，每个都会创建。

5% 是一个任意常数。这里选择的具体值是链在 Ethereum 验证者集的更新程度和保持更新的成本之间做出的权衡。此值越高，在最坏情况下劫持桥接所需的投票验证者集部分就越低。如果我们每个区块都进行新的验证者集更新，则需要 66% 串通，5% 的变化阈值意味着在给定验证者集中串通的 61% 的总投票权可能能够窃取桥接中的资金。

```
A -> B -> C -> D
     5%  10%   15%
```

中继者应该遍历 Peggy Ethereum 合约的事件历史，它将确定验证者集 A 目前在 Peggy 桥接中。它可以选择中继验证者集 B、C 然后 D，或者简单地提交验证者集 D。假设所有验证者都已签署 D，它拥有超过 66% 的投票权，可以自行通过。无需支付可能数百美元的 Ethereum 费用来中继中间集。

在提交交易之前，以某种方式在本地执行此检查对于成本有效的中继者实现至关重要。您可以使用本地 Ethereum 签名实现并自己汇总权重和签名，或者您可以简单地使用 `eth_call()` Ethereum RPC 在您的 Ethereum 节点上模拟调用。

请注意，`eth_call()` 经常有有趣的陷阱。如果您没有任何 Ethereum 来支付 gas，所有调用在基于 Geth 的实现上都会失败，而在基于 Parity 的实现上，您的 gas 输入大多被忽略，并返回准确的 gas 使用量。

## 交易批次中继的语义

为了提交交易批次，您还需要提交最后一组验证者及其质押权重。这是为了促进那里提到的相同存储优化。

### 决定中继哪个批次

决定中继哪个批次与决定中继哪个验证者集非常不同。批次中继主要由费用驱动，而不是为了维护桥接的完整性。因此，决定主要归结为费用计算，这进一步被"批次请求"的概念复杂化。这是一个无权限的交易，请求 Peggy 模块为特定代币类型生成新批次。

批次请求旨在允许用户在任何时候从发送到 Ethereum 交易池中提取其代币，直到中继者表现出实际中继它们的兴趣。当交易在池中时，如果允许用户通过发送 MsgCancelSendToEth 来提取它们，则没有双重支付的风险。一旦交易由于"请求批次"而进入批次，情况就不再如此，用户的资金必须保持锁定，直到 Oracle 通知 Peggy 模块包含用户代币的批次已变得无效无法提交或已在 Ethereum 上执行。

中继者使用查询端点 `BatchFees` 遍历每个代币类型的发送到 Eth 交易池，然后中继者可以观察在 dex 上中继的 ERC-20 代币的价格，并计算执行批次的 gas 成本（通过 `eth_call()`）以及如果需要，在 dex 上清算收益的 gas 成本。一旦中继者确定批次良好且有利可图，它可以发送 `MsgRequestBatch`，批次将为中继者创建以进行中继。

还有现有的批次，中继者还应该判断其盈利能力，并使用大致相同的方法尝试中继。
